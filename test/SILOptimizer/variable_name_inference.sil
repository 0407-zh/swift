// RUN: %target-sil-opt -module-name infer -test-runner %s 2>&1 | %FileCheck %s

import Builtin

//===----------------------------------------------------------------------===//
//                             MARK: Declarations
//===----------------------------------------------------------------------===//

class Klass {
}

class ContainsKlass {
  var computedKlass: Klass { get }
  final var klass: Klass

  init()
}

sil @getKlass : $@convention(thin) () -> @owned Klass
sil @getContainsKlass : $@convention(thin) () -> @owned ContainsKlass
sil @useIndirect : $@convention(thin) <T> (@in_guaranteed T) -> ()

//===----------------------------------------------------------------------===//
//                                MARK: Tests
//===----------------------------------------------------------------------===//

// CHECK-LABEL: begin running test {{[0-9]+}} of {{[0-9]+}} on simple_test_case: variable-name-inference with: @trace[0]
// CHECK: Input Value:   %1 = apply %0() : $@convention(thin) () -> @owned Klass
// CHECK: Name: 'MyName'
// CHECK: Root:   %1 = apply %0() : $@convention(thin) () -> @owned Klass
// CHECK: end running test {{[0-9]+}} of {{[0-9]+}} on simple_test_case: variable-name-inference with: @trace[0]
sil [ossa] @simple_test_case : $@convention(thin) () -> () {
bb0:
  specify_test "variable-name-inference @trace[0]"
  %0 = function_ref @getKlass : $@convention(thin) () -> @owned Klass
  %1 = apply %0() : $@convention(thin) () -> @owned Klass
  debug_value [trace] %1 : $Klass
  debug_value %1 : $Klass, let, name "MyName"
  destroy_value %1 : $Klass
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test {{[0-9]+}} of {{[0-9]+}} on temporary_init_with_copy_addr: variable-name-inference with: @trace[0]
// CHECK: Input Value:   %4 = alloc_stack $Klass
// CHECK: Name: 'MyName'
// CHECK: Root:   %2 = alloc_stack $Klass, var, name "MyName"
// CHECK: end running test {{[0-9]+}} of {{[0-9]+}} on temporary_init_with_copy_addr: variable-name-inference with: @trace[0]
sil [ossa] @temporary_init_with_copy_addr : $@convention(thin) () -> () {
bb0:
  specify_test "variable-name-inference @trace[0]"
  %0 = function_ref @getKlass : $@convention(thin) () -> @owned Klass
  %1 = apply %0() : $@convention(thin) () -> @owned Klass
  %2 = alloc_stack $Klass, name "MyName"
  store %1 to [init] %2 : $*Klass

  %temp = alloc_stack $Klass
  copy_addr %2 to [init] %temp : $*Klass
  debug_value [trace] %temp : $*Klass
  %use = function_ref @useIndirect : $@convention(thin) <T> (@in_guaranteed T) -> ()
  apply %use<Klass>(%temp) : $@convention(thin) <T> (@in_guaranteed T) -> ()

  destroy_addr %temp : $*Klass
  dealloc_stack %temp : $*Klass
  destroy_addr %2 : $*Klass
  dealloc_stack %2 : $*Klass
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test {{[0-9]+}} of {{[0-9]+}} on temporary_init_with_store: variable-name-inference with: @trace[0]
// CHECK: Input Value:   %3 = alloc_stack $Klass
// CHECK: Name: 'MyName'
// CHECK: Root:   %1 = apply %0()
// CHECK: end running test {{[0-9]+}} of {{[0-9]+}} on temporary_init_with_store: variable-name-inference with: @trace[0]
sil [ossa] @temporary_init_with_store : $@convention(thin) () -> () {
bb0:
  specify_test "variable-name-inference @trace[0]"
  %0 = function_ref @getKlass : $@convention(thin) () -> @owned Klass
  %1 = apply %0() : $@convention(thin) () -> @owned Klass
  debug_value %1 : $Klass, name "MyName", let

  %temp = alloc_stack $Klass
  store %1 to [init] %temp : $*Klass
  debug_value [trace] %temp : $*Klass
  %use = function_ref @useIndirect : $@convention(thin) <T> (@in_guaranteed T) -> ()
  apply %use<Klass>(%temp) : $@convention(thin) <T> (@in_guaranteed T) -> ()

  destroy_addr %temp : $*Klass
  dealloc_stack %temp : $*Klass
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test {{.*}} of {{.*}} on look_through_accessors_get: variable-name-inference with: @trace[0]
// CHECK: Name: 'myName.computedKlass'
// CHECK: Root: %2 = move_value [lexical] [var_decl]
// CHECK: end running test {{.*}} of {{.*}} on look_through_accessors_get: variable-name-inference with: @trace[0]
sil [ossa] @look_through_accessors_get : $@convention(thin) () -> () {
bb0:
  specify_test "variable-name-inference @trace[0]"
  %0 = function_ref @getContainsKlass : $@convention(thin) () -> @owned ContainsKlass
  %1 = apply %0() : $@convention(thin) () -> @owned ContainsKlass
  %3 = move_value [lexical] [var_decl] %1 : $ContainsKlass
  debug_value %3 : $ContainsKlass, let, name "myName"
  %5 = begin_borrow %3 : $ContainsKlass
  %6 = class_method %5 : $ContainsKlass, #ContainsKlass.computedKlass!getter : (ContainsKlass) -> () -> Klass, $@convention(method) (@guaranteed ContainsKlass) -> @owned Klass
  %7 = apply %6(%5) : $@convention(method) (@guaranteed ContainsKlass) -> @owned Klass
  debug_value [trace] %7 : $Klass
  end_borrow %5 : $ContainsKlass
  destroy_value %7 : $Klass
  destroy_value %3 : $ContainsKlass
  %13 = tuple ()
  return %13 : $()
}
