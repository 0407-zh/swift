// RUN: %target-sil-opt -unit-test-runner %s -o /dev/null 2>&1 | %FileCheck %s

sil_stage canonical

import Builtin

enum FakeOptional<T> {
case none
case some(T)
}

class C {}
class D {
  var object: C
  @_borrowed @_hasStorage var borrowed: C { get set }
}

struct PairC {
  var first: C
  var second: C
}

// CHECK-LABEL: testSelfLoop: ssa-liveness
// CHECK: SSA lifetime analysis:   [[V:%.*]] = copy_value %0 : $C
// CHECK: bb1: LiveOut
// CHECK: bb2: LiveWithin
// CHECK: lifetime-ending user:   br bb1([[V]] : $C)
// CHECK: last user:   br bb1([[V]] : $C)
// CHECK-NOT: dead def
sil [ossa] @testSelfLoop : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  br bb3

bb1(%1 : @owned $C):
  destroy_value %1 : $C
  %2 = copy_value %0 : $C
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %2 : $C
  br bb2

bb2:
  br bb1(%2 : $C)

bb3:
  %99 = tuple()
  return %99 : $()
}

// CHECK-LABEL: testSelfKill: ssa-liveness
// CHECK:SSA lifetime analysis:   [[V:%.*]] = move_value %1 : $C
// CHECK: bb1: LiveOut
// CHECK: bb2: LiveWithin
// CHECK: lifetime-ending user:   br bb1([[V]] : $C)
// CHECK: last user:   br bb1([[V]] : $C)
// CHECK-NOT: dead def
sil [ossa] @testSelfKill : $@convention(thin) () -> () {
bb0:
  br bb3

bb1(%1 : @owned $C):
  %2 = move_value %1 : $C
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %2 : $C
  br bb2

bb2:
  br bb1(%2 : $C)

bb3:
  %99 = tuple()
  return %99 : $()
}

// Test a live range that is extended through reborrows,
// considering them new defs.
// (e.g. BorrowedValue::visitTransitiveLifetimeEndingUses)
//
// This live range is not dominated by the original borrow.
//
// CHECK-LABEL: testReborrow: multidef-liveness
// CHECK: MultiDef lifetime analysis:
// CHECK:   def:   [[B:%.*]] = begin_borrow %0 : $C
// CHECK:   def:   [[RB:%.*]] = argument of bb3 : $C
// CHECK-NEXT: bb2: LiveWithin
// CHECK-NEXT: bb3: LiveWithin
// CHECK-NEXT: lifetime-ending user:   br bb3([[B]] : $C)
// CHECK-NEXT: lifetime-ending user:   end_borrow [[RB]] : $C
// CHECK-NEXT: last user:   br bb3([[B]] : $C)
// CHECK-NEXT: last user:   end_borrow [[RB]] : $C
sil [ossa] @testReborrow : $@convention(thin) (@owned C) -> () {
bb0(%0 : @owned $C):
  cond_br undef, bb1, bb2

bb1:
  %borrow1 = begin_borrow %0 : $C
  br bb3(%borrow1 : $C)

bb2:
  %borrow2 = begin_borrow %0 : $C
  test_specification "multidef-liveness @trace[0] @trace[1]"
  debug_value [trace] %borrow2 : $C
  br bb3(%borrow2 : $C)

bb3(%reborrow : @guaranteed $C):
  debug_value [trace] %reborrow : $C
  end_borrow %reborrow : $C
  br bb4

bb4:
  destroy_value %0 : $C
  %99 = tuple()
  return %99 : $()
}

// CHECK-LABEL: testGuaranteedForwarding: ssa-liveness
// CHECK: SSA lifetime analysis:   [[C:%.*]] = unchecked_ref_cast %{{.*}} : $D to $C
// CHECK: bb0: LiveWithin
// CHECK: regular user: %{{.*}} = load [copy]
// CHECK: last user:    %{{.*}} = load [copy]
sil [ossa] @testGuaranteedForwarding : $@convention(thin) (@owned D) -> () {
bb0(%0 : @owned $D):
  %borrow0 = begin_borrow %0 : $D
  %c = unchecked_ref_cast %borrow0 : $D to $C
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %c : $C
  %d = unchecked_ref_cast %c : $C to $D
  %f = ref_element_addr %d : $D, #D.object
  %o = load [copy] %f : $*C
  end_borrow %borrow0 : $D
  destroy_value %o : $C
  destroy_value %0 : $D
  %99 = tuple()
  return %99 : $()
}

// CHECK-LABEL: testGuaranteedResult: ssa-liveness
// CHECK: SSA lifetime analysis: %0 = argument of bb0 : $D
// CHECK: bb0: LiveWithin
// CHECK: last user:   end_apply
sil [ossa] @testGuaranteedResult : $@convention(thin) (@guaranteed D) -> () {
bb0(%0 : @guaranteed $D):
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %0 : $D
  %2 = class_method %0 : $D, #D.borrowed!read : (D) -> () -> (), $@yield_once @convention(method) (@guaranteed D) -> @yields @guaranteed C
  (%3, %4) = begin_apply %2(%0) : $@yield_once @convention(method) (@guaranteed D) -> @yields @guaranteed C
  end_apply %4
  %99 = tuple()
  return %99 : $()
}

// CHECK-LABEL: testScopedAddress: ssa-liveness
// CHECK: SSA lifetime analysis: %{{.*}} = ref_element_addr %0
// CHECK: bb0: LiveWithin
// CHECK: last user: end_access
sil [ossa] @testScopedAddress : $@convention(thin) (@guaranteed D) -> () {
bb0(%0 : @guaranteed $D):
  %f = ref_element_addr %0 : $D, #D.object
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %f : $*C
  %access = begin_access [read] [static] %f : $*C
  %o = load [copy] %access : $*C
  end_access %access : $*C
  destroy_value %o : $C
  %99 = tuple()
  return %99 : $()
}

// CHECK-LABEL: testDeadAddress: ssa-liveness
// CHECK: SSA lifetime analysis: %0 = argument of bb0 : $D
// CHECK: bb0: LiveWithin
// CHECK: last user: %{{.*}} = ref_element_addr
sil [ossa] @testDeadAddress : $@convention(thin) (@guaranteed D) -> () {
bb0(%0 : @guaranteed $D):
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %0 : $D
  %f = ref_element_addr %0 : $D, #D.object
  %99 = tuple()
  return %99 : $()
}

// A LiveOut block with a non-SSA def, bb0, has no liveness boundary.
//
// CHECK-LABEL: testMultiDefLiveOutNoBoundary: multidef-liveness
// CHECK: MultiDef lifetime analysis:
// CHECK:   def: [[CP0:%.*]] = copy_value %0 : $C
// CHECK:   def: %{{.*}} = copy_value %0 : $C
// CHECK:   def: %{{.*}} = move_value [[CP0]] : $C
// CHECK:   def: %{{.*}} = argument of bb4 : $C
// CHECK-NEXT: bb0: LiveOut,
// CHECK-NEXT: bb2: LiveWithin,
// CHECK-NEXT: bb3: LiveWithin,
// CHECK-NEXT: bb4: LiveWithin,
// CHECK-NEXT: bb1: LiveWithin,
// CHECK: last user:   br bb4
// CHECK-NEXT: last user:   br bb4
// CHECK-NEXT: last user:   %{{.*}} = move_value [[CP0]] : $C
// CHECK-NEXT: last user:   destroy_value %{{.*}} : $C
// CHECK-NEXT: last user:   destroy_value [[CP0]] : $C
sil [ossa] @testMultiDefLiveOutNoBoundary : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  %copy0 = copy_value %0 : $C
  test_specification "multidef-liveness @trace[0] @trace[1] @trace[2] @trace[3]"
  debug_value [trace] %copy0 : $C
  cond_br undef, bb1, bb3

bb1:
  destroy_value %copy0 : $C
  br bb2

bb2:
  %copy2 = copy_value %0 : $C
  debug_value [trace] %copy2 : $C
  br bb4(%copy2 : $C)

bb3:
  %copy3 = move_value %copy0 : $C
  debug_value [trace] %copy3 : $C
  br bb4(%copy3 : $C)

bb4(%phi : @owned $C):
  debug_value [trace] %phi : $C
  destroy_value %phi : $C
  %99 = tuple()
  return %99 : $()
}

// A dead (ref_element_addr) projection is treated like a pointer
// escape for convenience. Make sure the pointer escape bubbles up
// through the phi and casts.
//
// CHECK-LABEL: testSSADeadRefElementAddr: ssa-liveness
// CHECK: SSA lifetime analysis: %0 = argument of bb0 : $C
// CHECK-NEXT: Incomplete liveness: Escaping address
// CHECK-NEXT: bb0: LiveOut,
// CHECK-NEXT: bb2: LiveOut,
// CHECK-NEXT: bb3: LiveWithin,
// CHECK-NEXT: bb1: LiveOut,
// CHECK: last user:
// CHECK-SAME: ref_element_addr %6 : $D, #D.object
// CHECK-NEXT-LABEL: end running test 1 of 1 on testSSADeadRefElementAddr: ssa-liveness
sil [ossa] @testSSADeadRefElementAddr : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %0 : $C
  cond_br undef, bb1, bb2

bb1:
  %d1 = unchecked_ref_cast %0 : $C to $D
  br bb3(%d1 : $D)
  
bb2:
  %d2 = unchecked_ref_cast %0 : $C to $D
  br bb3(%d2 : $D)

bb3(%phi : @guaranteed $D):
  %f = ref_element_addr %phi : $D, #D.object  
  %99 = tuple()
  return %99 : $()
}

// One of the uses is a reborrowed inner borrow scope.
//
// CHECK-LABEL: testSSAInnerReborrowedPhi: ssa-liveness
// CHECK: SSA lifetime analysis: %0 = argument of bb0 : $C
// CHECK-NEXT: Incomplete liveness: Reborrowed inner scope
// CHECK-NEXT: bb0: LiveWithin,
// CHECK-NEXT: dead def: %0 = argument of bb0 : $C
sil [ossa] @testSSAInnerReborrowedPhi : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %0 : $C
  %borrow0 = begin_borrow %0 : $C
  %aggregate = struct $PairC(%borrow0 : $C, %borrow0 : $C)
  br bb1(%borrow0 : $C, %aggregate : $PairC)

bb1(%reborrow : @guaranteed $C, %phi : @guaranteed $PairC):
  %first = struct_extract %phi : $PairC, #PairC.first
  %d = unchecked_ref_cast %first : $C to $D
  %f = ref_element_addr %d : $D, #D.object  
  %o = load [copy] %f : $*C
  destroy_value %o : $C
  end_borrow %reborrow : $C
  %99 = tuple()
  return %99 : $()
}

// Confusingly, deadPhi is the "last use", but it does not cause its
// operands to be live-out of the predecessor block. This is because
// liveness considers all phis to end liveness on the predecessor side
// by default. Only the client can tell that a particular guaranteed phi
// should actually extend liveness if it has no uses.
//
// CHECK-LABEL: testSSADeadGuaranteedPhi: ssa-liveness
// CHECK: SSA lifetime analysis: %0 = argument of bb0 : $C
// CHECK-NEXT: bb0: LiveOut,
// CHECK-NEXT: bb2: LiveWithin,
// CHECK-NEXT: bb1: LiveWithin,
// CHECK-NEXT: regular user
// CHECK: last user:
// CHECK-SAME: br bb3
// CHECK-NEXT: last user:   br bb3
// CHECK-NEXT: end running
sil [ossa] @testSSADeadGuaranteedPhi : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %0 : $C
  cond_br undef, bb1, bb2

bb1:
  %d1 = unchecked_ref_cast %0 : $C to $D
  br bb3(%d1 : $D)
  
bb2:
  %d2 = unchecked_ref_cast %0 : $C to $D
  br bb3(%d2 : $D)

bb3(%phi : @guaranteed $D):
  %99 = tuple()
  return %99 : $()
}

// The phi is part of the guaranteed argument's simple live range.
//
// CHECK-LABEL: testSSADominatedPhi: ssa-liveness
// CHECK: SSA lifetime analysis: %0 = argument of bb0 : $C
// CHECK-NEXT: bb0: LiveOut,
// CHECK-NEXT: bb2: LiveOut,
// CHECK-NEXT: bb3: LiveWithin,
// CHECK-NEXT: bb1: LiveOut,
// CHECK-NEXT: regular user:   %{{.*}} = unchecked_ref_cast %0 : $C to $D
// CHECK-NEXT: regular user:   br bb3
// CHECK-NEXT: regular user:   %{{.*}} = load
// CHECK-NEXT: regular user:   %{{.*}} = unchecked_ref_cast %0 : $C to $D
// CHECK-NEXT: regular user:   br bb3
// CHECK-NEXT: last user:   %{{.*}} = load
// CHECK-NEXT: end running
sil [ossa] @testSSADominatedPhi : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %0 : $C
  cond_br undef, bb1, bb2

bb1:
  %d1 = unchecked_ref_cast %0 : $C to $D
  br bb3(%d1 : $D)
  
bb2:
  %d2 = unchecked_ref_cast %0 : $C to $D
  br bb3(%d2 : $D)

bb3(%phi : @guaranteed $D):
  %f = ref_element_addr %phi : $D, #D.object  
  %o = load [copy] %f : $*C
  destroy_value %o : $C
  %99 = tuple()
  return %99 : $()
}

// The phi is part of the guaranteed argument's simple live range.
//
// CHECK-LABEL: testSSAPartialDominatedPhi: ssa-liveness
// CHECK: SSA lifetime analysis: %0 = argument of bb0 : $C
// CHECK-NEXT: bb0: LiveOut,
// CHECK-NEXT: bb1: LiveWithin,
// CHECK: last user:
// CHECK-SAME: load
sil [ossa] @testSSAPartialDominatedPhi : $@convention(thin) (@guaranteed C, @guaranteed C) -> () {
bb0(%0 : @guaranteed $C, %1 : @guaranteed $C):
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %0 : $C
  %borrow1 = begin_borrow %1 : $C
  %aggregate = struct $PairC(%0 : $C, %borrow1 : $C)
  br bb1(%borrow1 : $C, %aggregate : $PairC)

bb1(%reborrow : @guaranteed $C, %phi : @guaranteed $PairC):
  %first = struct_extract %phi : $PairC, #PairC.first
  %d = unchecked_ref_cast %first : $C to $D
  %f = ref_element_addr %d : $D, #D.object  
  %o = load [copy] %f : $*C
  destroy_value %o : $C
  end_borrow %reborrow : $C
  %99 = tuple()
  return %99 : $()
}

// The phi is protected by an outer adjacent reborrow. It is not part
// of the guaranteed argument's simple live range. 
//
// CHECK-LABEL: testSSAReborrowedPhi: ssa-liveness
// CHECK: SSA lifetime analysis: %{{.*}} = begin_borrow
// CHECK-NEXT: bb0: LiveWithin,
// CHECK-NEXT: regular user: br bb1
// CHECK-NEXT: regular user: %{{.*}} = struct
// CHECK-NEXT: last user: br bb1
// CHECK-NEXT: end running
sil [ossa] @testSSAReborrowedPhi : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : @guaranteed $C):
  %borrow = begin_borrow %0 : $C
  test_specification "ssa-liveness @trace[0]"
  debug_value [trace] %borrow : $C
  %aggregate = struct $PairC(%borrow : $C, %borrow : $C)
  br bb1(%borrow : $C, %aggregate : $PairC)

bb1(%reborrow : @guaranteed $C, %phi : @guaranteed $PairC):
  %first = struct_extract %phi : $PairC, #PairC.first
  %d = unchecked_ref_cast %first : $C to $D
  %f = ref_element_addr %d : $D, #D.object  
  %o = load [copy] %f : $*C
  destroy_value %o : $C
  end_borrow %reborrow : $C
  %99 = tuple()
  return %99 : $()
}
