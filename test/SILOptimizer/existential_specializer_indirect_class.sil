// RUN: %target-sil-opt -O -wmo -enable-sil-verify-all %s | %FileCheck %s

sil_stage canonical

import Swift

protocol ClassProtocol: AnyObject { func method() }

class C: ClassProtocol { func method() {} }

// CHECK-LABEL: sil [signature_optimized_thunk] [always_inline] @test_indirect_class_protocol : $@convention(thin) (@in ClassProtocol) -> ()
sil @test_indirect_class_protocol : $@convention(thin) (@in ClassProtocol) -> () {
// CHECK-NEXT: //
// CHECK-NEXT: bb0(%0 : $*ClassProtocol):
bb0(%0 : $*ClassProtocol):
  // CHECK-NEXT: %1 = load %0
  // CHECK-NEXT: strong_release %1
  // CHECK-NEXT: strong_release %1
  destroy_addr %0 : $*ClassProtocol
  // CHECK-NEXT: return undef
  return undef : $()
}

// CHECK-LABEL: sil [signature_optimized_thunk] [always_inline] @test_indirect_class_protocol_guaranteed : $@convention(thin) (@in_guaranteed ClassProtocol) -> ()
sil @test_indirect_class_protocol_guaranteed : $@convention(thin) (@in_guaranteed ClassProtocol) -> () {
// CHECK-NEXT: //
// CHECK-NEXT: bb0(%0 : $*ClassProtocol):
bb0(%0 : $*ClassProtocol):
// CHECK-NEXT: [[INPUT:%1]] = load %0
  %1 = load %0 : $*ClassProtocol
  // CHECK-NEXT: [[OPENED:%.*]] = open_existential_ref [[INPUT]]
  // CHECK-NEXT: [[CLOSED:%.*]] = unchecked_ref_cast [[OPENED]]
  %2 = open_existential_ref %1 : $ClassProtocol to $@opened("ABCDEF01-ABCD-ABCD-ABCD-ABCDEFABCDEF") ClassProtocol
  // CHECK-NEXT: [[METHOD:%.*]] = witness_method $C, #ClassProtocol.method
  %f = witness_method $@opened("ABCDEF01-ABCD-ABCD-ABCD-ABCDEFABCDEF") ClassProtocol, #ClassProtocol.method!1 : <Self: ClassProtocol> (Self) -> () -> (), %2 : $@opened("ABCDEF01-ABCD-ABCD-ABCD-ABCDEFABCDEF") ClassProtocol : $@convention(witness_method : ClassProtocol) <Self: ClassProtocol> (@guaranteed Self) -> ()
  // CHECK-NEXT: apply [[METHOD]]<C>([[CLOSED]])
  apply %f<@opened("ABCDEF01-ABCD-ABCD-ABCD-ABCDEFABCDEF") ClassProtocol>(%2) : $@convention(witness_method : ClassProtocol) <Self: ClassProtocol> (@guaranteed Self) -> ()
  // CHECK-NEXT: strong_release [[INPUT]]
  // CHECK-NEXT: return undef
  return undef : $()
}

// CHECK-LABEL: sil @invoke_indirect_class_protocol : $@convention(thin) (@guaranteed C) -> ()

// Make sure both applies were inlined.

// CHECK-NEXT: //
// CHECK-NEXT: bb0(%0 : $C):

// CHECK-NEXT: [[METHOD:%.*]] = witness_method $C, #ClassProtocol.method
// CHECK-NEXT: strong_retain %0
// CHECK-NEXT: apply [[METHOD]]<C>(%0)

// CHECK-NEXT: strong_release %0
// CHECK-NEXT: strong_release %0
// CHECK-NEXT: strong_release %0

// CHECK-NEXT: return undef

sil @invoke_indirect_class_protocol : $@convention(thin) (@guaranteed C) -> () {
bb0(%0 : $C):
  %1 = init_existential_ref %0 : $C : $C, $ClassProtocol

  %z = alloc_stack $ClassProtocol
  retain_value %1 : $ClassProtocol
  store %1 to %z : $*ClassProtocol

  %f = function_ref @test_indirect_class_protocol_guaranteed : $@convention(thin) (@in_guaranteed ClassProtocol) -> ()
  apply %f(%z) : $@convention(thin) (@in_guaranteed ClassProtocol) -> ()

  %g = function_ref @test_indirect_class_protocol : $@convention(thin) (@in ClassProtocol) -> ()
  apply %g(%z) : $@convention(thin) (@in ClassProtocol) -> ()

  dealloc_stack %z : $*ClassProtocol
  return undef : $()
}
