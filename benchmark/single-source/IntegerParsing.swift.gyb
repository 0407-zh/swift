//===--- IntegerParsing.swift -------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

% # Ignore the following warning. This _is_ the correct file to edit.
////////////////////////////////////////////////////////////////////////////////
// WARNING: This file is manually generated from .gyb template and should not
// be directly modified. Instead, make changes to StringWalk.swift.gyb and run
// scripts/generate_harness/generate_harness.py to regenerate this file.
////////////////////////////////////////////////////////////////////////////////

import TestsUtils

% SizeNames = [ "IntSmall", "UIntSmall", "Int32", "Int64", "UInt32", "UInt64" ]
% SizeNamesLower\
%  = [ "intSmall", "uintSmall", "int32", "int64", "uint32", "uint64" ]
% SizeTypes = [ "Int", "UInt", "Int32", "Int64", "UInt32", "UInt64" ]
% SizeRanges = [ "-9999 ... 9999", "0 ... 9999" ] + ([ ".min ... .max" ] * 4)
% SizeSkippeds = [ False, True, True, False, True, True ]
% SizeIterationMultipliers = [ 20, 20, 8, 4, 8, 4 ]
% RadixNames = [ "Decimal", "Binary", "Hex", "UncommonRadix" ]
% Radices = [ 10, 2, 16, 7 ]

// - Definitions
public let IntegerParsing = [
% for (SizeName, SizeNameLower, SizeSkipped)\
%   in zip(SizeNames, SizeNamesLower, SizeSkippeds):
  // ${SizeName}
%   for RadixName in RadixNames:
  BenchmarkInfo(name: "ParseInt.${SizeName}.${RadixName}",
    runFunction: run_ParseIntFrom${SizeName}${RadixName},
    tags: [.validation, .api${", .skip" if SizeSkipped else ""}],
    setUpFunction: {
      blackHole(${SizeNameLower}ValuesSum)
      blackHole(${SizeNameLower}${RadixName}Strings)
  }),
%   end
% end
]

// - Verification Sums
% for (SizeNameLower, SizeType) in\
%   zip(SizeNamesLower, SizeTypes):
private let ${SizeNameLower}ValuesSum: ${SizeType}
  = ${SizeNameLower}Values.reduce(0, &+)
% end

// - Values
func generateValues<Integer : FixedWidthInteger>(
  in range: ClosedRange<Integer>, count: Int
) -> [Integer] {
    var rng = SplitMix64(seed: 42)
    return (0..<count).map { _ in
      Integer.random(in: range, using: &rng)
    }
}
% for (SizeNameLower, SizeType, SizeRange) in\
%   zip(SizeNamesLower, SizeTypes, SizeRanges):
private let ${SizeNameLower}Values: [${SizeType}]
  = generateValues(in: ${SizeRange}, count: 1000)
% end

// - Strings
% for (SizeName, SizeNameLower) in zip(SizeNames, SizeNamesLower):
// ${SizeName}
%   for (RadixName, Radix) in zip(RadixNames, Radices):
private let ${SizeNameLower}${RadixName}Strings: [String]
  = ${SizeNameLower}Values.map { String($0, radix: ${Radix}) }
%   end
% end

// - Implementations

% for (SizeName, SizeNameLower, SizeType, SizeIterationMultiplier)\
%   in zip(SizeNames, SizeNamesLower, SizeTypes, SizeIterationMultipliers):
// ${SizeName}
%   for (RadixName, Radix) in zip(RadixNames, Radices):
@inline(never)
public func run_ParseIntFrom${SizeName}${RadixName}(N: Int) {
  var result: ${SizeType} = 0
  let count = N * ${SizeIterationMultiplier}
  for _ in 0..<count {
    for string in ${SizeNameLower}${RadixName}Strings {
      result &+= ${SizeType}(string, radix: ${Radix})!
    }
  }
  CheckResults(result == ${SizeNameLower}ValuesSum &* ${SizeType}(count))
}

%   end
% end


