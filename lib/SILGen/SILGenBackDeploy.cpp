//===--- SILGenBackDeploy.cpp - SILGen for back deployment ----------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2022 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

#include "SILGenFunction.h"
#include "SILGenFunctionBuilder.h"
#include "Scope.h"
#include "swift/SIL/SILDeclRef.h"

using namespace swift;
using namespace Lowering;

/// Emit the following branch SIL instruction:
/// \verbatim
/// if #available(OSVersion) {
///   <availableBB>
/// } else {
///   <unavailableBB>
/// }
/// \endverbatim
static void emitBackDeployIfAvailableCondition(SILGenFunction &SGF,
                                               AbstractFunctionDecl *AFD,
                                               SILLocation loc,
                                               SILBasicBlock *availableBB,
                                               SILBasicBlock *unavailableBB) {
  PlatformKind platform = targetPlatform(SGF.SGM.getASTContext().LangOpts);
  auto introduced = AFD->getIntroducedOSVersion(platform);
  VersionRange OSVersion = VersionRange::empty();
  if (introduced.hasValue()) {
    OSVersion = VersionRange::allGTE(*introduced);
  }

  SILValue booleanTestValue;
  if (OSVersion.isEmpty() || OSVersion.isAll()) {
    // If there's no check for the current platform, this condition is
    // trivially true.
    SILType i1 = SILType::getBuiltinIntegerType(1, SGF.getASTContext());
    booleanTestValue = SGF.B.createIntegerLiteral(loc, i1, 1);
  } else {
    booleanTestValue = SGF.emitOSVersionRangeCheck(loc, OSVersion);
  }

  SGF.B.createCondBranch(loc, booleanTestValue, availableBB, unavailableBB);
}

/// Emits a function or method application, forwarding parameters.
SILValue emitBackDeployForwardApply(SILGenFunction &SGF,
                                    AbstractFunctionDecl *AFD, SILLocation loc,
                                    SILDeclRef function,
                                    SmallVector<SILValue, 8> &params,
                                    SILBasicBlock *rethrowBB) {
  TypeExpansionContext TEC = SGF.getTypeExpansionContext();
  auto fnType = SGF.SGM.Types.getConstantOverrideType(TEC, function);
  auto silFnType =
      SILType::getPrimitiveObjectType(fnType).castTo<SILFunctionType>();
  SILFunctionConventions fnConv(silFnType, SGF.SGM.M);

  if (silFnType->hasErrorResult())
    assert(rethrowBB && "must provide rethrow basic block");

  bool isClassMethod = false;
  if (auto classDecl = dyn_cast<ClassDecl>(AFD->getDeclContext())) {
    if (!classDecl->isFinal() && !AFD->isFinal() &&
        !AFD->hasForcedStaticDispatch())
      isClassMethod = true;
  }

  SILBasicBlock *normalBB = SGF.createBasicBlock();
  SILBasicBlock *errorBB = rethrowBB ? SGF.createBasicBlock() : nullptr;

  SILValue functionRef;
  if (isClassMethod) {
    auto selfValue = ManagedValue::forUnmanaged(SGF.F.getSelfArgument());
    functionRef =
        SGF.emitClassMethodRef(loc, selfValue.getValue(), function, fnType);
  } else {
    functionRef = SGF.emitGlobalFunctionRef(loc, function);
  }
  auto subs = SGF.F.getForwardingSubstitutionMap();

  if (errorBB) {
    SGF.B.createTryApply(loc, functionRef, subs, params, normalBB, errorBB);
  } else {
    auto result = SGF.B.createApply(loc, functionRef, subs, params);
    SGF.B.createBranch(loc, normalBB, {result});
  }

  if (errorBB) {
    SGF.B.emitBlock(errorBB);
    SILValue error = errorBB->createPhiArgument(fnConv.getSILErrorType(TEC),
                                                OwnershipKind::Owned);
    SGF.B.createBranch(loc, rethrowBB, {error});
  }

  SGF.B.emitBlock(normalBB);
  return normalBB->createPhiArgument(fnConv.getSILResultType(TEC),
                                     OwnershipKind::Owned);
}

void SILGenFunction::emitBackDeployedThunk(SILDeclRef thunk) {
  // Generate code equivalent to:
  //
  //  func X_thunk(...) async throws -> ... {
  //    if #available(...) {
  //      return try await X(...)
  //    } else {
  //      return try await X_clientCopy(...)
  //    }
  //  }

  assert(thunk.isBackDeployed);

  // Get a reference to the original declaration. We'll call the original
  // declaration at runtime if it is available.
  SILDeclRef original = thunk.asBackDeployed(false);
  auto AFD = cast<AbstractFunctionDecl>(thunk.getDecl());

  // Use the same generic environment as the original entry point.
  F.setGenericEnvironment(SGM.Types.getConstantGenericEnvironment(original));

  auto loc = thunk.getAsRegularLocation();
  loc.markAutoGenerated();
  Scope scope(Cleanups, CleanupLocation(loc));

  auto methodTy =
      SGM.Types.getConstantOverrideType(getTypeExpansionContext(), thunk);
  auto derivativeFnSILTy = SILType::getPrimitiveObjectType(methodTy);
  auto silFnType = derivativeFnSILTy.castTo<SILFunctionType>();
  SILFunctionConventions fnConv(silFnType, SGM.M);
  auto resultType = fnConv.getSILResultType(getTypeExpansionContext());

  // Gather params for forwarding.
  SmallVector<SILValue, 8> paramsForForwarding;
  bindParametersForForwarding(AFD->getParameters(), paramsForForwarding);
  if (auto *selfDecl = AFD->getImplicitSelfDecl())
    bindParameterForForwarding(selfDecl, paramsForForwarding);

  auto rethrowBB =
      silFnType->hasErrorResult() ? createBasicBlock("rethrowBB") : nullptr;
  auto returnBB = createBasicBlock("returnBB");

  SILBasicBlock *availableBB = createBasicBlock("availableBB");
  SILBasicBlock *unavailableBB = createBasicBlock("unavailableBB");

  //  if #available(...) {
  //    <availableBB>
  //  } else {
  //    <unavailableBB>
  //  }
  emitBackDeployIfAvailableCondition(*this, AFD, loc, availableBB,
                                     unavailableBB);

  // <availableBB>:
  //   return (try)? (await)? (self.)?X(...)
  {
    B.emitBlock(availableBB);
    SILValue result = emitBackDeployForwardApply(
        *this, AFD, loc, original, paramsForForwarding, rethrowBB);
    B.createBranch(loc, returnBB, {result});
  }

  // <unavailableBB>:
  //   return (try)? (await)? (self.)?X_clientCopy(...)
  {
    B.emitBlock(unavailableBB);
    // FIXME(backDeploy): Emit a forward apply of client copy of function
    ManagedValue undef = emitUndef(resultType);
    B.createBranch(loc, returnBB, {undef});
  }

  // Emit return logic.
  {
    B.emitBlock(returnBB);
    SILValue result =
        returnBB->createPhiArgument(resultType, OwnershipKind::Owned);

    B.createReturn(loc, result);
  }

  // Emit the rethrow logic.
  if (rethrowBB) {
    B.emitBlock(rethrowBB);
    SILValue error = rethrowBB->createPhiArgument(
        fnConv.getSILErrorType(getTypeExpansionContext()),
        OwnershipKind::Owned);

    Cleanups.emitCleanupsForReturn(CleanupLocation(loc), IsForUnwind);
    B.createThrow(loc, error);
  }
}
